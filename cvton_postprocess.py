# Postprocessing script to extract masks and mask metrics from an image generated by Densepose
# Version 0.1 : Dr Paul Goodman, NICD, Newcastle University, 27/01/2024

## IMPORT NECESSARY LIBRARIES
########################################################################################

import os
import glob
import json
import tkinter as tk
from tkinter.filedialog import askopenfilename
import skimage as ski
import numpy as np
import matplotlib.pyplot as plt
from scipy.ndimage import binary_dilation
import DenseposeGroupingColours as dgc

## Custom exception class 
class ScriptException(Exception):
    pass

## FUNCTION DEFS - Probably should be in a separate script...
########################################################################################

# Adds a buffer around a binary mask area of 'buffer_size' pixels
def addBufferToMask(mask, buffer_size=5):
    buffered_mask = binary_dilation(mask, iterations=buffer_size)
    return buffered_mask

# Counts the number of masked pixel blocks in an image 
def countImageBlocks(image, colour):
    mask = getBinaryMaskWithTolerance(image, colour)
    labeled_blocks = ski.measure.label(mask)
    num_blocks = np.max(labeled_blocks)
    return num_blocks

# Counts the number of masked pixel blocks within an already defined mask
def countMaskBlocks(mask):
    labeled_blocks = ski.measure.label(mask)
    num_blocks = np.max(labeled_blocks)
    return num_blocks

# Creates a mask based on a single, specified colour
def getBinaryMask(image, colour):
    mask = np.all(image == colour, axis=-1)
    return mask

# Creates a mask based on tolerance to a certain colour in linear space
def getBinaryMaskWithTolerance(image, target_color, tolerance=20):
    color_difference = np.linalg.norm(image - target_color, axis=-1)
    binary_mask = color_difference <= tolerance
    return binary_mask

# Get a directory by a file dialog
def getDirectoryByDialog(win_title):
    root = tk.Tk() 
    root.withdraw()
    path = tk.filedialog.askdirectory( title = win_title )
    print(f"Set path: '{path}'")
    return path 

# Get all files in a directory with extensions matching a filter list
def getFilesInDirectory(root, filters):
    file_list = []
    for ext in filters:
        pattern = f"{root}/*.{ext}"
        file_list.extend(glob.glob(pattern))
    return file_list

# Get an image filename by opening a file dialog
def getImageFileByDialog():
    root = tk.Tk() 
    root.withdraw()
    image_path = askopenfilename( 
        title="Select a .PNG file",
        filetypes=[("PNG files", "*.png"),("JPG files", "*.jpg"),("All files", "*.*")]
    ) 
    return image_path

# Create a composite mask based on lookup of body parts by densepose grouping dictionary key
def getGroupMask(image, group_name):
    composite_mask = np.zeros((image.shape[0], image.shape[1]), dtype=bool)
    group_idxs = grouping[group_name]
    #print(group_idxs)
    #print(composite_mask.shape)
    for idx in group_idxs:
        #print(f'idx: {idx} colour: {input_colours[idx]}')
        mask = getBinaryMaskWithTolerance(image, input_colours[idx])
        if mask_buffer > 0:
            mask = addBufferToMask(mask, mask_buffer)
        composite_mask = np.logical_or(composite_mask, mask)
    
    return composite_mask

# Get all measure data for the mask blocks 
def getMaskMeasureData(mask):
    labeled_mask = ski.measure.label(mask)
    regions = ski.measure.regionprops(labeled_mask)
    areas = [region.area for region in regions]
    bboxs = [region.bbox for region in regions]
    cents = [region.centroid for region in regions]
    count = len(regions)

    # Sort by descending area, get sorted indices, resort results by indices
    sorted_idxs = sorted(range(len(areas)), key=lambda k: areas[k], reverse=True)
    areas = [areas[i] for i in sorted_idxs]
    bboxs = [bboxs[i] for i in sorted_idxs]
    cents = [cents[i] for i in sorted_idxs]

    # Round centroid values and areas
    areas = [round(a) for a in areas]
    cents = [(round(y), round(x)) for y, x in cents]

    return count, areas, bboxs, cents

# Get rescaled metrics for a single body part (if necessary)
# NB: Creates a copy of the original metrics and returns the altered copy
def getRescaledMetrics(metrics, new_w, new_h):
    new_metrics = metrics
    if new_metrics['NORMALISED'] == True and new_w > 0 and new_h > 0:
        new_metrics['AREAS'] = [x * (new_w * new_h) for x in new_metrics['AREAS']]
        new_metrics['BBOXS'] = [(round(y1 * new_h), round(x1 * new_w), round(y2 * new_h), round(x2 * new_w)) for y1, x1, y2, x2 in new_metrics['BBOXS']]
        new_metrics['CENTS'] = [(round(y * new_h), round(x * new_w)) for y, x in new_metrics['CENTS']]
        new_metrics['NORMALISED'] = False
    return new_metrics

#Get rescaled results at the image level
def getRescaledResults(results, new_w, new_h):
    new_results = {}
    if new_w > 0 and new_h > 0:
        new_results = results
        for item in results['PART_LIST']:
            new_part_results = getRescaledMetrics(results[item], new_w, new_h)
            new_results[item] = new_part_results

    return new_results


# Normalise results if necessary
# NB: By Reference - Changes the data of the original metrics dict
def normaliseMetrics(metrics, i_w, i_h):
    if metrics['NORMALISED'] == False:
        metrics['AREAS'] = [x / (i_w * i_h) for x in metrics['AREAS']]
        metrics['BBOXS'] = [(y1 / i_h, x1 / i_w, y2 / i_h, x2 / i_w) for y1, x1, y2, x2 in metrics['BBOXS']]
        metrics['CENTS'] = [(y / i_h, x / i_w) for y, x in metrics['CENTS']]
        metrics['NORMALISED'] = True

# Plot the original image next to the specified masked image
def plotImageAndMask(image, mask, fig_title=None, win_title=None, results=None):
    # Add main title
    if not fig_title==None:
        plt.suptitle(fig_title)
    # Display the original image
    plt.subplot(1, 2, 1)
    plt.imshow(image)
    plt.title('Original Image')
    
    #Show results if available
    if not results==None:
        centroids = results['CENTS']
        if len(centroids) > 0:
            y, x = zip(*centroids)
            plt.scatter(x, y, color='white', marker='o')

        bboxs = results['BBOXS']
        if len(bboxs) > 0: 
            y1, x1, y2, x2 = zip(*bboxs)
            plt.plot([x1, x1], [y1, y2], linestyle='-', marker='o', color='w', label='Line 1')
            plt.plot([x1, x2], [y2, y2], linestyle='-', marker='o', color='w', label='Line 1')
            plt.plot([x2, x2], [y2, y1], linestyle='-', marker='o', color='w', label='Line 1')
            plt.plot([x2, x1], [y1, y1], linestyle='-', marker='o', color='w', label='Line 1')

    # Display the binary mask
    plt.subplot(1, 2, 2)
    plt.imshow(mask, cmap='gray')
    plt.title(f'Binary Mask')

    # Set window name
    fig_manager = plt.get_current_fig_manager()
    fig_manager.set_window_title(win_title)
    plt.show()

 # Write results to json file
def writeResults(results, output_path):
    filename = os.path.basename(results['FILE'])
    filename = os.path.splitext(filename)[0]
    filename += ".json"
    file_path = os.path.join(output_path, filename)
    with open(file_path, 'w') as json_file:
        json.dump(results, json_file, indent=4)

######################################################################################

# Setup image processing variables
image_path       = os.path.join(os.getcwd(), "results_cvton") # Base input path for images
output_path      = os.path.join(os.getcwd(), "results_cvton_dump") # Base output path for results
image_extensions = ['jpg','png'] # Allowed image extensions 
input_mode       = "CVTON" # This sets the colours that define the masks - see 'DenseposeGroupingColours.py'
input_colours    = dgc.input_mode_dict[input_mode]

# 'I'  = Interactive, select input and output directories by dialog, single file, don't show results
# 'IS' = Interactive, select input and output directories by dialog, single file, show results
# 'ID' = Interactive, select input and output directories by dialog, and process all images in the input directory, 
# 'D'  = Non-interactive, Process all images in 'image_path', with output going to 'output_path'
file_mode        = "D" 

grouping_mode    = "RAW" # This sets how densepose 'fine' classifications are aggregated - see 'DenseposeGroupingColours.py'
grouping         = dgc.group_mode_dict[grouping_mode]
mask_buffer      = 1 # The size of the buffer to put around masks in pixels
rescale_results  = True # Whether or not image metrics should be normalised
test_rescale     = False # Dump a reconstruction of images rescaled dictionaries for debugging

# Get the image(s) we want to process
if file_mode=="IS" or file_mode=="I":
    image_list  = [getImageFileByDialog()]
    if len(image_list) > 0:
        output_path = getDirectoryByDialog("Select Output Directory:") 
elif file_mode=="ID":
    image_path = getDirectoryByDialog("Select Image Directory:")
    image_list = getFilesInDirectory(image_path, image_extensions)
    if len(image_list) > 0: 
        output_path = getDirectoryByDialog("Select Output Directory:")
else:
    image_list = getFilesInDirectory(image_path, image_extensions)

print(f"Image path  : '{image_path}'")
print(f"Output path : '{output_path}'")
#print(f"Image list : {image_list}")

try:
    if len(image_path) < 2 or len(output_path) < 2:
        raise ScriptException("Script cancelled - directory error!")

    # Try to create the output directory if it doesn't exist,
    # If it does already exist, give warning that files will be overwritten 
    if not os.path.exists(output_path):
        os.makedirs(output_path)
        print(f"Created output directory : '{output_path}'")
    else:
        if any(os.listdir(output_path)):
            print("WARNING! : Files in output path will be overwritten!")

    if len(image_list) > 0 and os.path.exists(output_path): 
        for image_file in image_list:
            print(f"Processing : '{image_file}'")
            try:
                image = ski.io.imread(image_file)
                i_w = int(image.shape[1])
                i_h = int(image.shape[0])
                a_r = i_w / i_h
                #print(f"Image dims: {i_w} x {i_h}")
                results={}

                # Set image-level results data 
                results['FILE']       = os.path.basename(image_file)
                results['IM_MODE']    = input_mode
                results['IM_SHAPE']   = [i_h, i_w]
                results['ASP_RATIO']  = a_r
                results['GR_MODE']    = grouping_mode
                results['PART_COUNT'] = int(len(grouping))
                results['PART_LIST']  = list(grouping.keys())

                # Loop over body parts in the selected grouping
                for body_part in grouping.keys():
                    part_result={}
                    mask = getGroupMask(image, body_part)
                    count, areas, bboxs, cents = getMaskMeasureData(mask)
                    part_result['NAME'] = body_part
                    part_result['BLOCK_COUNT'] = int(count)
                    part_result['NORMALISED'] = False
                    part_result['AREAS'] = areas
                    part_result['BBOXS'] = bboxs
                    part_result['CENTS'] = cents         

                    # Interactive mode
                    if file_mode=="IS" or file_mode=="ID":
                        print(f"Part: {body_part}, Block count: {count}")
                        print(f"Areas: {areas}")
                        print(f"Centroids: {cents}")
                        print(f"Bounding Boxes: {bboxs}")         
                        plotImageAndMask(image, mask, body_part, os.path.basename(image_file), part_result)

                    # Rescale part results if necessary
                    if rescale_results==True:
                        normaliseMetrics(part_result, i_w, i_h)
                
                    #Add parts to the overall results dict for this image
                    results[body_part] = part_result
                                
            except:
                print(f"WARNING! : Unable to process image '{image_file}'")
                print("Exception: ", e)

            # Write the results
            #print(results)
            try:
                writeResults(results, output_path)
            except Exception as e: 
                print("WARNING! : Unable to write output file! Exception: ", e)

            # Test of reconstruction after scaling.
            if rescale_results==True and test_rescale==True:
                print(results)
                new_results = getRescaledResults(results, image.shape[1], image.shape[0])
                print(new_results)  
    print("EXIT : OK!")

except ScriptException as e:
    print("EXIT : ", e)
        