# Postprocessing script to extract masks and mask metrics from an image generated by Densepose
# Version 0.2 : Dr Paul Goodman, NICD, Newcastle University, 04/02/2024

## IMPORT NECESSARY LIBRARIES
########################################################################################

import os
import json
import skimage as ski
import cv2
import numpy as np
import matplotlib.pyplot as plt
from scipy.ndimage import binary_dilation
import cvton_colour_groupings as ccg
import pauls_utils as pu
import skeleton_functions as skel

## Custom exception class 
class ScriptException(Exception):
    pass

## FUNCTION DEFS - Probably should be in a separate script...
########################################################################################

# Adds a buffer around a binary mask area of 'buffer_size' pixels
def addBufferToMask(mask, buffer_size=5):
    buffered_mask = binary_dilation(mask, iterations=buffer_size)
    return buffered_mask

# Counts the number of masked pixel blocks in an image 
def countImageBlocks(image, colour):
    mask = getBinaryMaskWithTolerance(image, colour)
    labeled_blocks = ski.measure.label(mask)
    num_blocks = np.max(labeled_blocks)
    return num_blocks

# Counts the number of masked pixel blocks within an already defined mask
def countMaskBlocks(mask):
    labeled_blocks = ski.measure.label(mask)
    num_blocks = np.max(labeled_blocks)
    return num_blocks

def doPreprocessImage(image, show_image=False):
    #Get all non white pixels in the image.
    gray_image = ski.color.rgb2gray(image)
    binary_mask = gray_image > 0
    label_image = ski.measure.label(binary_mask)
    regions = ski.measure.regionprops(label_image)
    mask = np.zeros_like(gray_image, dtype=bool)
    areas = [region.area for region in regions]
    
    # Sort by descending area, get sorted indices, resort results by indices
    sorted_idxs = sorted(range(len(areas)), key=lambda k: areas[k], reverse=True)
     
    # Get largest area
    mask |= label_image == regions[sorted_idxs[0]].label

    # Retain image pixels within mask
    masked_image = image.copy()
    masked_image[~mask] = 0
   
    if (show_image==True):
        _, axs = plt.subplots(1, 2, figsize=(10, 5))
        axs[0].imshow(image)
        axs[0].set_title('Original Image')
        axs[1].imshow(masked_image)
        axs[1].set_title('Masked Image')
        plt.show()

    return masked_image

# Creates a mask based on a single, specified colour
def getBinaryMask(image, colour):
    mask = np.all(image == colour, axis=-1)
    return mask, colour

# Creates a mask based on tolerance to a certain colour in linear space
def getBinaryMaskWithTolerance(image, colour, tolerance=20):
    colour_diff = np.linalg.norm(image - colour, axis=-1)
    binary_mask = colour_diff <= tolerance
    return binary_mask, colour

# Create a composite mask based on lookup of body parts by densepose grouping dictionary key
def getGroupMask(image, group_name, mask_buffer=0, verbose = False):
    composite_mask = np.zeros((image.shape[0], image.shape[1]), dtype=bool)
    group_idxs = grouping[group_name]  
    
    if verbose == True:
        print(group_idxs)
        print(composite_mask.shape)
    
    for i, idx in enumerate(group_idxs):
        if i==0:
            key_colour = input_colours[idx]

        if verbose==True:
            print(f'idx: {idx} colour: {input_colours[idx]} key_colour: {key_colour}')
        
        mask, _ = getBinaryMaskWithTolerance(image, input_colours[idx])
        if mask_buffer > 0:
            mask = addBufferToMask(mask, mask_buffer)
        composite_mask = np.logical_or(composite_mask, mask)
    
    return composite_mask, key_colour

# Get pseudo-centroid based on the combination of largest head parts
def getHeadPoint(results, groupings):
    result=[]
    #get all body parts containing 'head'
    head_parts = [key for key in groupings.keys() if 'head' in key.lower()]
    #print(f"Head parts: {head_parts}")
    x = y = n = 0
    for part in head_parts:
        x = x + results[part]['CENTS'][0][1]
        y = y + results[part]['CENTS'][0][0]
        n = n + 1   
    result = [round(y/n), round(x/n)]
    return result

# Get sorted and clipped list of indices based on area
def getMaskSortedAndClippedRegionList(mask, max_parts=2, area_threshold = 0.25, area_ratio = 10):
    clipped_regions = []
    mask_shape = mask.shape
    min_area = round(area_threshold * mask_shape[0] * mask_shape[1] * 0.01)
    #print(f"base_min_area: {min_area}")

    # Get labled mask, region properties amd areas
    labeled_mask = ski.measure.label(mask)
    regions = ski.measure.regionprops(labeled_mask)
    # Sort by descending area, get sorted indices, resort results by indices
    sorted_regions = sorted(regions, key=lambda x: x.area, reverse=True)
    areas = [region.area for region in sorted_regions]
    
    #sorted_idxs = sorted(range(len(areas)), key=lambda k: areas[k], reverse=True)
    #print(f"Sorted idxs : {sorted_idxs}")
    
    #areas = [areas[i] for i in sorted_idxs]
    #print(f"Sorted areas: {areas}")

    # Get largest area and calculate threshold
    if len(areas)>0:
        min_area2 = round(areas[0] / area_ratio)
        min_area  = max(min_area, min_area2)
        #print(f"used_min_area: {min_area}")
        clipped_regions = [region for region in sorted_regions if region.area > min_area]
        if len(clipped_regions)>max_parts:
            clipped_regions = clipped_regions[:max_parts]
    
    return clipped_regions

# Get all measure data for the mask blocks 
def getMaskMeasureData(regions):
    count = 0
    areas = bboxs = cents = []

    if len(regions)>0:       
        areas = [region.area for region in regions]
        bboxs = [region.bbox for region in regions]
        cents = [region.centroid for region in regions]
        count = len(regions)

        # Round centroid values and areas
        areas = [round(a) for a in areas]
        bboxs = [[y1, x1, y2, x2] for y1, x1, y2, x2 in bboxs]
        cents = [[round(y), round(x)] for y, x in cents]

    return count, areas, bboxs, cents

def getMaskObjectOrientedBoundingBoxes(regions):
    oobbs      = []
    oobb_cents = []
    oobb_mids  = []
   
    if len(regions)>0: 
        #largest_region_index = np.argmax([region.area for region in regions])
        for region in regions:
            region_pixels = np.array(region.coords, dtype=np.int32)
            #print(region_pixels.shape)
            cv2_oobb = cv2.minAreaRect(region_pixels)
            oobb = cv2.boxPoints(cv2_oobb).astype(int).tolist()
            oobb_cent = getOOBBCentrePoint(oobb)
            oobb_mid  = getOOBBEdgeMidpoints(oobb)
            oobbs.append(oobb)
            oobb_cents.append(oobb_cent)
            oobb_mids.append(oobb_mid)
    
    return oobbs, oobb_cents, oobb_mids

# Gets an OOBB for a given mask image using cv2
def getOOBB(mask, flip=False):
    points = np.array(maskToPoints(mask), dtype=np.float32)
    rect = cv2.minAreaRect(points)
    box_vertices = cv2.boxPoints(rect).astype(int)
    
    if flip==True:
        box_vertices = [[x, y] for y, x in box_vertices]
    
    return box_vertices

# Get the average point of an OOBB
def getOOBBCentrePoint(oobb):
    result = []
    if len(oobb)>0:
        y1, x1, y2, x2, y3, x3, y4, x4 = [item for sublist in oobb for item in sublist]
        ya = round((y1 + y2 + y3 + y4)/4)
        xa = round((x1 + x2 + x3 + x4)/4)
        result = [ya, xa]
    return result

def getOOBBEdgeMidpoints(oobb):
    result = []
    if len(oobb)>0:
        y1, x1, y2, x2, y3, x3, y4, x4 = [item for sublist in oobb for item in sublist]
        #print(f"{y1}, {x1}, {y2}, {x2}, {y3}, {x3}, {y4}, {x4}")
        #print(f"{(y1+y2)/2}")
        result.append([round((y1+y2)/2), round((x1+x2)/2)])       
        result.append([round((y2+y3)/2), round((x2+x3)/2)])
        result.append([round((y3+y4)/2), round((x3+x4)/2)])
        result.append([round((y4+y1)/2), round((x4+x1)/2)])
    
    result = sorted(result, key=lambda coord: (coord[0], coord[1]))
    #print(f"Sorted points: {result}")
    return result

# Get rescaled metrics for a single body part (if necessary)
# NB: Creates a copy of the original metrics and returns the altered copy
def getRescaledMetrics(metrics, new_w, new_h):
    new_metrics = metrics
    if new_metrics['NORMALISED'] == True and new_w > 0 and new_h > 0:
        new_metrics['AREAS'] = [x * (new_w * new_h) for x in new_metrics['AREAS']]
        new_metrics['BBOXS'] = [(round(y1 * new_h), round(x1 * new_w), round(y2 * new_h), round(x2 * new_w)) for y1, x1, y2, x2 in new_metrics['BBOXS']]
        new_metrics['CENTS'] = [(round(y * new_h), round(x * new_w)) for y, x in new_metrics['CENTS']]
        new_metrics['OOBB_CENTS'] = [[round(y * new_h), round(x * new_w)] for y, x in metrics['OOBB_CENTS']]       
        new_metrics['OOBBS'] = [[[round(y * new_h), round(x * new_w)] for y, x in regions] for regions in metrics['OOBBS']]           
        new_metrics['OOBB_MIDS'] = [[[round(y * new_h), round(x * new_w)] for y, x in regions] for regions in metrics['OOBB_MIDS']]           
        new_metrics['NORMALISED'] = False
    return new_metrics

#Get rescaled results at the image level
def getRescaledResults(results, new_w, new_h):
    new_results = {}
    if new_w > 0 and new_h > 0:
        new_results = results
        for item in results['PART_LIST']:
            new_part_results = getRescaledMetrics(results[item], new_w, new_h)
            new_results[item] = new_part_results
    new_results['IM_SHAPE'] = [new_h, new_w]
    return new_results

# Convert an image mask to a numpy array of white pixels
def maskToPoints(mask):
    # Find white pixels in the mask
    white_pixels = np.column_stack(np.where(mask > 0))
    return white_pixels
    
# Normalise results if necessary
# NB: By Reference - Changes the data of the original metrics dict
def normaliseMetrics(metrics, w, h):
    if metrics['NORMALISED'] == False:
        metrics['AREAS'] = [x / (w * h) for x in metrics['AREAS']]
        metrics['BBOXS'] = [[y1 / h, x1 / w, y2 / h, x2 / w] for y1, x1, y2, x2 in metrics['BBOXS']]
        metrics['CENTS'] = [[y / h, x / w] for y, x in metrics['CENTS']]
        metrics['OOBB_CENTS'] = [[y / h, x / w] for y, x in metrics['OOBB_CENTS']]       
        metrics['OOBBS'] = [[[y / h , x / w] for y, x in regions] for regions in metrics['OOBBS']]           
        metrics['OOBB_MIDS'] = [[[y / h , x / w] for y, x in regions] for regions in metrics['OOBB_MIDS']]
        metrics['NORMALISED'] = True

# Plot the original image next to the specified masked image
def plotImageAndMask(image, mask, fig_title=None, win_title=None, results=None):
    # Add main title
    if not fig_title==None:
        plt.suptitle(fig_title)
    # Display the original image
    plt.subplot(1, 2, 1)
    plt.imshow(image)
    plt.title('Original Image')
    
    #Show results if available
    if not results==None:
        centroids = results['CENTS']
        if len(centroids) > 0:
            y, x = zip(*centroids)
            plt.scatter(x, y, color='white', marker='*')

        bboxs = results['BBOXS']
        if len(bboxs)>0: 
            y1, x1, y2, x2 = zip(*bboxs)
            plt.plot([x1, x1], [y1, y2], linestyle='-', marker='o', color='w', label='Line 1')
            plt.plot([x1, x2], [y2, y2], linestyle='-', marker='o', color='w', label='Line 1')
            plt.plot([x2, x2], [y2, y1], linestyle='-', marker='o', color='w', label='Line 1')
            plt.plot([x2, x1], [y1, y1], linestyle='-', marker='o', color='w', label='Line 1')

    # Display the binary mask
    plt.subplot(1, 2, 2)
    plt.imshow(mask, cmap='gray')
    plt.title(f'Binary Mask')
    if not results==None and len(results)>0:
        oobbs = results['OOBBS']
        oobb_cents = results['OOBB_CENTS']
        #oobb_mids = results['OOBB_MIDS']
        if len(oobbs)>0:
            for oobb in oobbs:
                if len(oobb)>0:
                    y1, x1, y2, x2, y3, x3, y4, x4 = [coord for pair in oobb for coord in pair]
                    plt.plot([x1, x2], [y1, y2], linestyle='-', marker='o', color='r', label='Line 1')
                    plt.plot([x2, x3], [y2, y3], linestyle='-', marker='o', color='g', label='Line 2')
                    plt.plot([x3, x4], [y3, y4], linestyle='-', marker='o', color='b', label='Line 3')
                    plt.plot([x4, x1], [y4, y1], linestyle='-', marker='o', color='y', label='Line 4') 
        if len(oobb_cents)>0:
            y, x = zip(*oobb_cents)
            plt.scatter(x, y, color='r', marker='*') 
                    
    # Set window name
    fig_manager = plt.get_current_fig_manager()
    fig_manager.set_window_title(win_title)
    plt.show()

 # Write results to json file
def writeResults(image_data, results, skeleton,  output_path):
    combined_dict = {}
    combined_dict['IMAGE_DATA'] = image_data
    combined_dict['BODY_PARTS'] = results
    combined_dict['SKELETON'] = skeleton
        
    filename = os.path.basename(combined_dict['IMAGE_DATA']['FILE'])
    filename = os.path.splitext(filename)[0]
    filename += ".json"
    print(f"Output to file: '{filename}'")
    file_path = os.path.join(output_path, filename)
    with open(file_path, 'w') as json_file:
        json.dump(combined_dict, json_file, indent=4)

######################################################################################

# Setup image processing variables
image_path       = os.path.join(os.getcwd(), "results_cvton") # Base input path for images
output_path      = os.path.join(os.getcwd(), "results_cvton_dump") # Base output path for results
image_extensions = ['jpg','png'] # Allowed image extensions 
input_mode       = "CVTON" # This sets the colours that define the masks - see 'DenseposeGroupingColours.py'
input_colours    = ccg.input_mode_dict[input_mode]

# 'I'  = Interactive, select input and output directories by dialog, single file, don't show results
# 'IS' = Interactive, select input and output directories by dialog, single file, show results
# 'ID' = Interactive, select input and output directories by dialog, and process all images in the input directory, 
# 'D'  = Non-interactive, Process all images in 'image_path', with output going to 'output_path'
file_mode        = "D" 

grouping_mode    = "RAW" # This sets how densepose 'fine' classifications are aggregated - see 'DenseposeGroupingColours.py'
grouping         = ccg.group_mode_dict[grouping_mode]
skeleton         = ccg.skeleton_mode_dict[grouping_mode]
mask_buffer      = 1 # The size of the buffer to put around masks in pixels
rescale_results  = True # Whether or not image metrics should be normalised
test_rescale     = False # Dump a reconstruction of rescaled results dictionary for debugging
test_control_pts = False # Generate some test control points on a skeleton
show_results     = True # Show the results of mask area, centroid and AABB peocessing
show_skeleton    = True # Show the results of OOBB and skeleton processing

max_parts        = 2 # How many region blocks per body part to process
area_threshold   = 0.25 # Blocks less than this area of the image as a percentage will be removed from processing
area_ratio       = 10 # Areas less than this ratio of the largest area will be removed from processing     

# Get the image(s) we want to process
if file_mode=="IS" or file_mode=="I":
    image_list  = [pu.getImageFileByDialog()]
    if len(image_list) > 0:
        output_path = pu.getDirectoryByDialog("Select Output Directory:") 
elif file_mode=="ID":
    image_path = pu.getDirectoryByDialog("Select Image Directory:")
    image_list = pu.getFilesInDirectory(image_path, image_extensions)
    if len(image_list) > 0: 
        output_path = pu.getDirectoryByDialog("Select Output Directory:")
else:
    image_list = pu.getFilesInDirectory(image_path, image_extensions)

print(f"Image path  : '{image_path}'")
print(f"Output path : '{output_path}'")
#print(f"Image list : {image_list}")

try:
    # Try to create the output directory if it doesn't exist,
    # If it does already exist, give warning that files will be overwritten 
    if not isinstance(output_path, tuple):
        if not os.path.exists(output_path):
            os.makedirs(output_path)
            print(f"Created output directory : '{output_path}'")
        if any(os.listdir(output_path)):
            print("WARNING! : Files in output path will be overwritten!")
     
    # Check directories exist
    if isinstance(image_path, tuple) or isinstance(output_path, tuple):
        raise ScriptException("Script cancelled - no image or output directory name!")

    if not os.path.exists(image_path) or not os.path.exists(output_path):
        raise ScriptException("Script cancelled - image or output directory does not exist!")

    if len(image_list)==0:
        raise ScriptException("Image list is empty - nothing to process!")

    for image_file in image_list:
        print(f"Processing : '{image_file}'")
        try:
            image = ski.io.imread(image_file)
            i_w = int(image.shape[1])
            i_h = int(image.shape[0])
            a_r = i_w / i_h

            # Check image to see if there may be multiple people in frame
            image = doPreprocessImage(image)

            #print(f"Image dims: {i_w} x {i_h}")
            image_data = {}
            results    = {}
            skeleton   = {}

            # Set image-level results data 
            image_data['FILE']       = os.path.basename(image_file)
            image_data['IM_MODE']    = input_mode
            image_data['IM_SHAPE']   = [i_h, i_w]
            image_data['ASP_RATIO']  = a_r
            results['GR_MODE']       = grouping_mode
            results['PART_COUNT']    = int(len(grouping))
            results['PART_LIST']     = list(grouping.keys())

            # Loop over body parts in the selected grouping
            for body_part in grouping.keys():
                #print(f"{body_part}")
                part_result={}
                mask, colour = getGroupMask(image, body_part, mask_buffer)
                regions = getMaskSortedAndClippedRegionList(mask, 
                                                            max_parts=max_parts, 
                                                            area_threshold = area_threshold, 
                                                            area_ratio = area_ratio)
                oobbs, oobb_cents, oobb_mids = getMaskObjectOrientedBoundingBoxes(regions)
                count, areas, bboxs, cents = getMaskMeasureData(regions)
                #print("-------------------------------")
                part_result['NAME'] = body_part
                part_result['RGB'] = list(colour) 
                part_result['BLOCK_COUNT'] = int(count)
                part_result['NORMALISED'] = False
                part_result['AREAS'] = areas
                part_result['BBOXS'] = bboxs
                part_result['CENTS'] = cents
                part_result['OOBBS'] = oobbs 
                part_result['OOBB_CENTS'] = oobb_cents
                part_result['OOBB_MIDS'] = oobb_mids        
                            
                #Add parts to the overall results dict for this image
                results[body_part] = part_result

            # Get the head point 
            results['HEAD_PT'] = getHeadPoint(results, grouping)
            
            # Process the skeleton 
            skeleton = {}
            new_bones = skel.skeletonGetBonesTorsoAndHead(results)
            skeleton.update(new_bones)
            new_bones = skel.skeletonGetShoulderBones(results)
            skeleton.update(new_bones)
            new_bones = skel.skeletonGetUpperArmBones(results, skeleton)
            skeleton.update(new_bones)
            new_bones = skel.skeletonGetLowerArmBones(results, skeleton)
            skeleton.update(new_bones)
            new_bones = skel.skeletonGetHands(results, skeleton)
            skeleton.update(new_bones)
            new_bones = skel.skeletonGetHipBones(results, skeleton)
            skeleton.update(new_bones)
            new_bones = skel.skeletonGetUpperLegBones(results, skeleton)
            skeleton.update(new_bones)
            new_bones = skel.skeletonGetLowerLegBones(results, skeleton)
            skeleton.update(new_bones)
            new_bones = skel.skeletonGetFeet(results, skeleton)
            skeleton.update(new_bones)
                            
            # Dump outputs in interactive modes
            if file_mode=="IS" or file_mode=="ID":
                print("-------------oOo--------------")
                print("BODY_PARTS:")
                for body_part in grouping.keys():
                    print(f"Part: {results[body_part]['NAME']}, Block count: {results[body_part]['BLOCK_COUNT']}")
                    print(f"Head point    : {results['HEAD_PT']}")
                    print(f"Colour        : {results[body_part]['RGB']}")
                    print(f"Is normalised?: {results[body_part]['NORMALISED']}")
                    print(f"Areas         : {results[body_part]['AREAS']}")
                    print(f"Centroids     : {results[body_part]['CENTS']}")
                    print(f"Bounding Boxes: {results[body_part]['BBOXS']}") 
                    print(f"OOBBs         : {results[body_part]['OOBBS']}")  
                    print(f"OOBB Centers  : {results[body_part]['OOBB_CENTS']}") 
                    print(f"OOBB_Mids     : {results[body_part]['OOBB_MIDS']}")
                    print("------------bBb---------------")
                
                    print("SKELETON:")
                    for key, bones in skeleton.items():
                        print(f"{key} : {bones}")
                        print("------------xXx---------------")
                
                if show_results==True:
                    plotImageAndMask(image, 
                                     mask, 
                                     body_part, 
                                     os.path.basename(image_file), 
                                     part_result)
              

            #Test of bone control groups
            if test_control_pts==True:
                bone_groups = skel.skeletonGetUsedBoneGroups(skeleton)
                control_points = []
                for group in bone_groups:
                    print("------------------------------")
                    print(f"Group: {group}")
                    pt = skel.skeletonGetBoneControlPoint(skeleton, group, 0.2)
                    control_points.append(pt)
                    print("------------------------------")
                    print(f"Control points : {control_points}")


            if show_skeleton==True:
                if file_mode=="IS" or file_mode=="ID":
                    skel.plotImageAndSkeleton(image, 
                                              results   = results, 
                                              groupings = grouping, 
                                              skeleton  = skeleton,  
                                              win_title = os.path.basename(image_file))

            # Third pass for normalisation of parts
            # Rescale part results if necessary
            if rescale_results==True:
                for body_part in grouping.keys():
                    part_result = results[body_part]
                    normaliseMetrics(part_result, i_w, i_h)
                for bone in skeleton.keys():
                    #print(f"Normalising: '{bone}'")
                    bone_result = skeleton[bone]
                    skeleton[bone] = skel.skeletonNormaliseBoneMetrics(bone_result, i_w, i_h)

            
        except:
            print(f"WARNING! : Unable to process image '{image_file}'")
            print("Exception: ", e)

        # Write the results
        try:
            writeResults(image_data, results, skeleton, output_path)
        except Exception as e: 
            print("WARNING! : Unable to write output file! Exception: ", e)

        # Test of reconstruction after scaling.
        if rescale_results==True and test_rescale==True:
            print("--------------------------------")
            print(results)
            print("--------------------------------")
            new_results = getRescaledResults(results, image.shape[1], image.shape[0])
            print(new_results)
            new_skeleton = skel.skeletonGetRescaledBoneMetrics(skeleton, image.shape[1], image.shape[0])
            print(new_skeleton)
            print("--------------------------------")  
    
    print("EXIT : OK!")

except:
    print("EXIT : ON EXCEPTION!")
        